# 객체지향 프로그래밍 1 
OOP :  객체지향 프로그램

- 객체지향언어 특징
    - 코드의 `재사용성이 높다`
    - 코드의 `관리가 용이하다`
    - 신뢰성이 높은 프로그래밍을 가능하게 한다.
        - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록하며,
        `중복된 코드 제거`하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

<br>

## 🌿 클래스

- 클래스 → `객체 어떻게 사용하는지 신청서,설계도`
    - 정의 : 객체를 정의한 것
    - 용도 : 객체를 생성하는데 사용

- 한 파일에 여러클래스 작성하기
    - `하나의 소스 파일에 하나의 클래스만 정의하는 것`이 바람직
    - 올바른 작성 예
        - public class 있는 경우, 소스 파일이름 = public class 이름
        - public class 없는 경우, 둘중 하나만 소스파일 이름과 같으면 된다.
    - 잘못된 작성 예
        - public class 여러개x → 하나만 존재해야함
        - 소스 파일이름 불일치하는 경우(대소문자도)

### 클래스의 정의

1. 설계도
2. 데이터와 함수의 결합
3. 사용자 정의 타입

<br>

2. **데이터와 함수의 결합**
    1. 프로그래밍 언어에서 데이터 처리를 위한 **데이터 저장형태의 발전과정**
    
    <img width="489" alt="image" src="https://user-images.githubusercontent.com/102898794/201468784-70afce4e-690b-4586-949a-7a7618fe287a.png">

    
    > 1.  **변수** : 하나의 데이터를 **저장할 수 있는 공간
    2. 배열** : 같은 종류의 여러 데이터를 **하나의 집합**으로 저장할 수 있는 공간
    3. **구조체** : 서로 관련된 여러 데이터를 **종류에 관계없이 하나의 집합으로 저장**할 수 있는 공간
    4. **클래스** : **데이터와 함수의 결합**(구조체+함수)
    > 
- 
    - 함수는 주로 데이터를 가지고 작업을 하기 때문에 많은 경우에 있어 **데이터와 함수는 관계가 깊음**
    - 자바와 같은 객체지향언어에서는 **변수(데이터)**와 함께 **함수**를 **하나의 클래스에 정의**하여 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있게 함
    - 서로 관련된 **변수들을 정의**하고 이들에 대한 작업을 수행하는 **함수들을 함께 정의**한 것이 **클래스**
- C언어에서는 문자열을 문자의 배열로 다루지만, **자바**에서는 **String**이라는 클래스로 **문자열**을 다룸
    - **String을**  클래스로 정의한 이유
    →  **`문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위함`**

3. ****************************사용자 정의 타입****************************
    1. 원하는 타입으로 만들 수 있음
- 자바와 같은 객체지향언어에서는 **클래스가 곧 사용자 정의 타입**임
- 기본형의 개수는 8개로 정해져 있지만, **참조형의 개수가 정해져 있지 않은 이유**는 **프로그래머가 새로운 타입을 추가**할 수 있기 때문

<br>

## 🌿객체 = 속성+기능

```
속성(property) -> 멤버변수(variable)
기능(function) -> 메서드(method)
```

- 정의 : 실제로 존재하는 것, 사물 또는 개념
- 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름
- 유형의객체(사물), 무형의 객체(논리나 개념)

  `클래스 —(인스턴스화)→ 인스턴스(객체)`

객체 = 인스턴스

객체 : 모든 인스턴스를 대표하는 일반적인 용어

인스턴스 : 특정 클래스로부터 생성된 객체

**
 클래스 왜 필요? → 객체 생성 위해

객체 왜 필요? → 객체 사용 위해

객체 사용? → 객체 가진 속성(변수),기능(메서드,println) 사용하려고

### 객체 생성과 사용

`인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.`

```java
클래스명 변수명;             //클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명();     //클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t;                    //TV클래스 타입의 **참조변수 t**를 선언
t = new Tv();            //TV인스턴스를 생성 후, 생성된 Tv인스턴스의 주소를 t에 저장
```

### 객체 배열

`객체 배열 = 참조변수 배열`

```java
Tv tv1,tv2,tv3; -> Tv[] tvArr = new Tv[];
```

: 이렇게 객체 배열을 만듬으로써 `객체의 주소`를 저장할수 있게 된다

→ **아직 참조변수들이 만들어진 것뿐, 객체가 저장되지는 않음**

- ***객체 생성 → 객체 배열의 각 요소에 저장 필수***
    
    ```java
    Tv[] tvArr = new Tv[3]; //참조변수 배열(객체배열)을 생성
    
    //객체를 생성해서 배열의 각 요소에 저장
    tvArr[0] = new Tv();
    tvArr[1] = new Tv();
    tvArr[2] = new Tv();
    ```
    

- 저장할 때 배열의 초기화 블럭 또는 for문 사용하면  된다
    - 배열의 초기화 블럭
        
        ```java
        Tv[] tvArr ={new Tv(),new Tv(),new Tv()};
        ```
        
    - 다뤄야할 객체 수가 많을 때  for문
        
        ```java
        Tv[] tvArr = new Tv[100];
        
        for(int i = 0;i<tvArr.length;i++){
        	tvArr[i] = new Tv();
        }
        ```
        

<br>

## 🌿 변수

### 선언위치에 따른 변수의 종류

```java
class Variables
{
	int iv;        //인스턴스 변수
	static int cv; //클래스 변수(static 변수, 공유변수)
	
	void method(){
	int lv = 0;    //지역변수
	}
}
```

- 클래스 변수(cv) : `static o` , 객체 생성 안해도 됨
    - 클래스 변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.
    - 인스턴스 생성하지 않고 바로 사용가능
    - ‘`클래스 이름.클래스 변수`’와 같은 형식으로 사용
- 인스턴스 변수(iv) : static x, `객체 생성 필수되어야함`
    - 인스턴스마다 별도의 저장공간을 가지므로 서로 다른 값을 가질 수 있다. (`독립적인 저장공간`)
    ⇒ 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수로 선언한다.
- 지역변수(lv) : 메서드 내에서만 사용가능

| 변수의 종류 | 선언위치 | 생성시기 |
| --- | --- | --- |
| 클래스 변수(class variable) | 클래스영역 | 클래스가 메모리에 올라갈 때, 설계도필요할때, 객체 만들때 |
| 인스턴스 변수(instance variable) | 클래스영역 | 인스턴스가 생성되었을 때 |
| 지역변수(local variable) | 클래스 영역 이외의 영역(메서드,생성자, 초기화 블럭 내부) | 변수 선언문이 수행되었을 때 |

<br>

## 🌿 메서드  = 선언부 + 구현부

> - 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다. → 함수느낌
- 하나의 메서드는 한가지 기능만 수행하도록 작성
> 

```java
반환타입 메서드 (타입 변수명, 타입 변수명, ...){  // 선언부
//메서드 호출 시 수행될 코드                   // 구현부
}
```

- 메서드 장점
    - 코드 중복 줄일 수 있다
    - 코드 관리 용이
    - 코드 재사용
    - 코드 간결 → 이해 쉬워짐

### 메서드 선언부 / 구현부

<img width="526" alt="image" src="https://user-images.githubusercontent.com/102898794/201468835-aa2da5b9-a796-4ed0-b28d-85a4315f358b.png">

- 매개변수 선언(parameter declaration)
    - 변수의 타입이 같아도 변수의 타입을 생략할 수 없음
    `int add(int x, y){….} → y의 타입이 x와 같더라도 명시해줘야한다`
- 반환타입
    - 반환타입으로 ‘void’ 를 쓰면 반환값이 없는 반환타입(return 안써줘도 됨)
    - 반환타입 ‘void’ 아닌 경우 return 은 구현부 안에 반드시 포한되어야한다
    - return문은 단 하나의 값만 반환할 수 있다.(매개변수가 여러개더라도 반환값은 최대 하나)
- 지역변수(local variable)
    - 다른 메서드면 같은 이름의 변수를 선언해도 된다.

### 메서드의 호출

<img width="304" alt="image" src="https://user-images.githubusercontent.com/102898794/201468840-0ee81ba4-6d06-40a5-933d-4937b5abdf0b.png">

- 인수(argument)와 매개변수(parameter)
    - 인수(인자) : 메서드를 호출할때 () 안에 지정해준 값들
    - 인수는 호출되면 파라미터에 대입되므로 `인자 타입 = 매개변수 타입` or 자동형변환 가능해야한다
    
- 메서드의 실행 흐름

<img width="496" alt="image" src="https://user-images.githubusercontent.com/102898794/201468849-5f710fd4-f452-4251-ad47-f8b93a644c4e.png">

<br>

## 🌿 return

반환타입이 void인 경우, return문 없이도 아무런 문제가 없었던 이유는

`컴파일러가 메서드의 마지막에 ‘return’을 자동적으로 추가해주었기 때문에`

예외에는 반드시 return문 필요

반환값의 타입이 값을 경우 멤버변수 적지 않고 **return 값에 바로 결과값 적어줄 수 있음**

<br>

## 🌿 호출스택(call stack)

> 메서드의 작업에 필요한 메모리 공간을 제공한다.
> 
1. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며,
    1. 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간 결과 등을 저장하는데 사용된다
2. 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비어진다 

### 호출스택특징

- 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
- 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

### 매개변수

- 기본형 매개변수
    - 변수의 값을 읽기만 할 수있다.
    - 기본형 값이 복사
- 참조형 매개변수
    - 변수의 값을 읽고 변경할 수 있다.→ 값이 저장된 곳의 주소를 알 수 있기 때문에
    - 인스턴스의 주소가 복사
- 참조형 반환타입
    - 모든 참조형 타입의 값은 ‘객체의 주소’이므로 그저 정수값이 반환되는 것일뿐 특별한 것은 없다.

<br>

## 🌿 static

- 클래스메서드(static사용) → 객체생성x, ‘클래스이름.메섣드이름(매개변수)’로 호출 가능
- 인스턴스 메서드 → 반드시 객체 생성 필요

- static 사용 여부는 인스턴스 멤버 유무에 따라 달라집

! 인스턴스 변수를 사용하지 않는다고 해서 반드시 클래스 메서드로 정의해야하는 것은 아니지만 특별한 이유가 없는 한 그렇게 하는 것이 일반적

### static을 붙여야할 때

1. 클래스 설계할때, 멤버변수 중 모든 인스턴스에 공통으로 상용하는 것에 static 붙임
    1. 생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지한다.
    2. `그러나` 모든 인스턴스에서 같은 값이 유지 되어야 하는 변수는 static 붙임
2. 클래스변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
    1. 클래스변수는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문에
3. 클래스 메서드는 인스턴스 변수 사용할 수 없다.
    1. 인스턴스 변수 or 인스턴스 메서드 있을때
        1. static변수가 이미 메모리에 존재한다는 것을 의미
    2. 클래스 메서드만 있을때
        1. 클래스 메서드는 인스턴스 생성 없이 호출가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다.
        → 클래스 메서드에서 인스턴스 변수의 사용을 금지

**정리**

- 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있으면, static붙여준다
- 작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static붙일 것을 고려
    - 메서드 호출시간이 짧아지므로 성능이 향상된다.

### 🌿 메서드 간의 호출과 참조

- 같은 클래스에 속하면 별도의 객체 생성안고 서로 참조 호출 가능
    - 단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출 할 때 인스턴스 생성
    
     `**인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만,**`
    
    `**클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다**`

<br>
    

## 🌿 오버로딩(overloading) = 메서드 오버로딩

> 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것
> 

### 오버로딩 조건

1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야한다.
3. 반환 타입은 관계없다.

**반환타입은 오버로딩을 구현하는데 아무런 영향을 못한다**

<br>

## 🌿 생성자 (constructor)

> 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’
> 
- 인스턴스의 초기화 작업에 주로 사용
- 인스턴스 생성시 실행되어야하는 작업을 위해서도 사용

```java
클래스 이름(타입 변수명, 타입 변수명,...){
//인스턴스 생성시 수행될 코드,
//주로 인스턴스 변수의 초기화 코드를 적는다
}
```

### 특징

- 클래스 내에 선언
- 클래스의 이름과 같아야한다.
- 오버로딩 가능
- 리턴 값 없음
    - 모든 생성자는 리턴값이 없기 때문에 리턴타입 void 적지 않음
- 연산자 new가 인스턴스를 생성하는 것이지 생성자를 인스턴스를 생성하는 것이 아니다.
    - 단순히 인스턴스 변수들의 초기화에 사용

*“  모든 클래스에는 반드시 하나 이상의 생성자가 정의 되어있어야 한다!”*

### 기본 생성자(default constructor)

`클래스이름(){}`

- 지금까지 클래스에 생성자 정의하지 않고도 인스턴스를 생성할 수 있었던 이유
    - 컴파일러가 자동적으로 기본 생성자 추가하여 컴파일 한다.
        
        `컴파일러가 추가해주는 생성자는 매개변수, 아무 내용없는 아주 간단한 것`
        
    - 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

### 매개변수 있는 생성자

```java
car(){} //기본생성자
car(String c, String g, int b){ //생성자, 매개변수0
	color = c;
	gearType = g;
	door = d;
```

```java
Car c =new Car();
c.color = "white";
c.gearType="auto";
c.door=4;
//인스턴스 초기화
```

→

```java
Car c 
= new Car("white","auto",4)
//객체생성과 객체초기화,생성자 호출 한번에 
```

→ 인스턴스를 생성한 다음 인스턴스 변수의 값을 변경하는 것보다

`매개변수를 갖는 생성자를 사용하는 것이 코드를 간결하고 직관적으로 만든다`

<br>

## this() vs this

### this ()

: 생성자에서 다른 생성자 호출하기

조건

- 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 `첫 줄에서만 호출이 가능하다`

```java
Car2(){
	color = "white";
	gearType="auto";
	door=4;
}
```

→

```java
Car2(){
	this("white","auto",4)
```

### 참조변수 this

- 인스턴스 자신을 가르키는 참조변수, 인스턴스의 주소가 저장되어있음
- 인스턴스 메서드(생성자 포함)에서 사용가능
    - 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재
    - `클래스(static)메서드 에서는 사용 못함`
        
        → static 메서드는 인스턴스 생성 안해도 사용가능, 그래서 static메서드가 호출된 시점에 인스턴스가 존재하지 않을 수 있기 때문에
        

```java
Car(String c,String g, int d){
	color =c;
	gearType = g;
	door = d;
}

```

- 같은 클래스 내에서 생략 가능

→

```java
Car(String color,String gearType
, int door){
		this.color =color;
		this.gearType = gearType;
		this.door = door;
}
```

- 만약 이름이 같으면 생략x

<br>

## 🌿 변수의 초기화

> 변수를 선언하고 처음으로 값을 저장하는 것
> 
- 멤버변수(클래스변수,인스턴스 변수) : 자동으로 초기화
- `지역변수 : 사용하기 전 반드시 초기화!!`

### 멤버변수의 초기화

> 각 타입의 기본값으로 자동초기화
> 
- 기본형은 자동으로 되지만, 참조형은 객체를 넣어줘야한다
    
    순서
    
    - 클래스 변수→인스턴스 변수
    - 자동초기화 → 명시적 초기화(간단)→ 초기화 블럭,생성자(복잡)

초기화 시점

- cv : `클래스 처음 로딩될 때 단 한번` (메모리 올라갈때)
- lv : 인스턴스 생성될 때마다
